<!DOCTYPE html>
<html lang="en">
<head>
    <title>three.js - pointerlock controls</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">
    <style>
        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }

        #instructions {
            width: 100%;
            height: 100%;

            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;

            text-align: center;
            font-size: 14px;
            cursor: pointer;
        }
    </style>
</head>
<body>
<div id="blocker">
    <div id="instructions">
        <p style="font-size:36px">
            Click to play
        </p>
        <p>
            Move: WASD<br/>
            Jump: SPACE<br/>
            Look: MOUSE
        </p>
    </div>
</div>

<script type="importmap">
    {
        "imports": {
            "three": "/build/three.module.js",
            "three/addons/": "/jsm/"
        }
    }
</script>

<script type="module">

    import * as THREE from 'three';

    import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

    let camera, parameters, scene, renderer, controls;

    const objects = [];

    let moveForward = false;
    let moveBackward = false;
    let moveLeft = false;
    let moveRight = false;
    let canJump = false;

    let prevTime = performance.now();
    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();
    const vertex = new THREE.Vector3();
    const color = new THREE.Color();

    const materials = [];

    init();

    function init() {

        camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1000 );
        camera.position.y = 10;

        scene = new THREE.Scene();
        scene.background = new THREE.Color( 0x000000 );
        //scene.fog = new THREE.Fog( 0xffffff, 0, 750 );

        const light = new THREE.HemisphereLight( 0xeeeeff, 0x777788, 2.5 );
        light.position.set( 0.5, 1, 0.75 );
        scene.add( light );

        controls = new PointerLockControls( camera, document.body );
        const blocker = document.getElementById( 'blocker' );
        const instructions = document.getElementById( 'instructions' );
        instructions.addEventListener( 'click', function () {
            controls.lock();
        } );

        controls.addEventListener( 'lock', function () {
            instructions.style.display = 'none';
            blocker.style.display = 'none';
        } );

        controls.addEventListener( 'unlock', function () {
            blocker.style.display = 'block';
            instructions.style.display = '';
        } );

        scene.add( controls.object );

        const onKeyDown = function ( event ) {
            switch ( event.code ) {
                case 'KeyW':
                    moveForward = true;
                    break;
                case 'KeyA':
                    moveLeft = true;
                    break;
                case 'KeyS':
                    moveBackward = true;
                    break;
                case 'KeyD':
                    moveRight = true;
                    break;
                case 'Space':
                    if ( canJump === true ) velocity.y += 350;
                    canJump = false;
                    break;
            }

        };

        const onKeyUp = function ( event ) {

            switch ( event.code ) {
                case 'KeyW':
                    moveForward = false;
                    break;
                case 'KeyA':
                    moveLeft = false;
                    break;
                case 'KeyS':
                    moveBackward = false;
                    break;
                case 'KeyD':
                    moveRight = false;
                    break;
            }
        };

        document.addEventListener( 'keydown', onKeyDown );
        document.addEventListener( 'keyup', onKeyUp );


        // floor
        let floorGeometry = new THREE.PlaneGeometry( 2000, 2000, 100, 100 );
        floorGeometry.rotateX( - Math.PI / 2 );
        // vertex displacement
        let position = floorGeometry.attributes.position;
        for ( let i = 0, l = position.count; i < l; i ++ ) {
            vertex.fromBufferAttribute( position, i );
            vertex.x += Math.random() * 20 - 10;
            vertex.y += Math.random() * 2;
            vertex.z += Math.random() * 20 - 10;
            position.setXYZ( i, vertex.x, vertex.y, vertex.z );
        }
        floorGeometry = floorGeometry.toNonIndexed(); // ensure each face has unique vertices
        position = floorGeometry.attributes.position;
        const colorsFloor = [];
        for ( let i = 0, l = position.count; i < l; i ++ ) {
            color.setHSL( Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75, THREE.SRGBColorSpace );
            colorsFloor.push( color.r, color.g, color.b );
        }
        floorGeometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colorsFloor, 3 ) );
        const floorMaterial = new THREE.MeshBasicMaterial( { vertexColors: true } );
        const floor = new THREE.Mesh( floorGeometry, floorMaterial );
        scene.add( floor );

        // snowflakes
        const geometry = new THREE.BufferGeometry();
        const vertices = [];
        const textureLoader = new THREE.TextureLoader();
        const assignSRGB = ( texture ) => {
            texture.colorSpace = THREE.SRGBColorSpace;
        };

        const sprite1 = textureLoader.load( 'textures/sprites/snowflake1.png', assignSRGB );
        const sprite2 = textureLoader.load( 'textures/sprites/snowflake2.png', assignSRGB );
        const sprite3 = textureLoader.load( 'textures/sprites/snowflake3.png', assignSRGB );
        const sprite4 = textureLoader.load( 'textures/sprites/snowflake4.png', assignSRGB );
        const sprite5 = textureLoader.load( 'textures/sprites/snowflake5.png', assignSRGB );

        for ( let i = 0; i < 40000; i ++ ) {
            const x = Math.random() * 2000 - 1000;
            const y = Math.random() * 2000 - 1000;
            const z = Math.random() * 2000 - 1000;
            vertices.push( x, y, z );
        }

        geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );

        parameters = [
            [[ 1.0, 1.0, 1.0 ], sprite2, 5 ],
            [[ 1.0, 1.0, 1.0 ], sprite3, 6 ],
            [[ 0.90, 1.0, 1.0 ], sprite1, 8 ],
            [[ 0.85, 1.0, 1.0 ], sprite5, 4 ],
            [[ 0.80, 1.0, 1.0 ], sprite4, 2 ]
        ];

        for ( let i = 0; i < parameters.length; i ++ ) {

            const color = parameters[ i ][ 0 ];
            const sprite = parameters[ i ][ 1 ];
            const size = parameters[ i ][ 2 ];

            materials[ i ] = new THREE.PointsMaterial( { size: size, map: sprite, blending: THREE.AdditiveBlending, depthTest: false, transparent: true } );
            materials[ i ].color.setHSL( color[ 0 ], color[ 1 ], color[ 2 ], THREE.SRGBColorSpace );

            const particles = new THREE.Points( geometry, materials[ i ] );
            particles.rotation.x = Math.random() * 6;
            particles.rotation.y = Math.random() * 6;
            particles.rotation.z = Math.random() * 6;
            scene.add( particles );
        }

        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.setAnimationLoop( animate );
        document.body.appendChild( renderer.domElement );
        window.addEventListener( 'resize', onWindowResize );

    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( window.innerWidth, window.innerHeight );
    }

    function animate() {
        const time = performance.now();
        if ( controls.isLocked === true ) {

            const delta = ( time - prevTime ) / 1000;

            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;

            velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass

            direction.z = Number( moveForward ) - Number( moveBackward );
            direction.x = Number( moveRight ) - Number( moveLeft );
            direction.normalize(); // this ensures consistent movements in all directions

            if ( moveForward || moveBackward ) velocity.z -= direction.z * 900.0 * delta;
            if ( moveLeft || moveRight ) velocity.x -= direction.x * 900.0 * delta;

            controls.moveRight( - velocity.x * delta );
            controls.moveForward( - velocity.z * delta );

            controls.object.position.y += ( velocity.y * delta ); // new behavior

            if ( controls.object.position.y < 10 ) {
                velocity.y = 0;
                controls.object.position.y = 10;
                canJump = true;
            }

            for ( let i = 0; i < scene.children.length; i ++ ) {
                const object = scene.children[ i ];
                if ( object instanceof THREE.Points ) {
                    //object.rotation.y = Date.now() * 0.00005 * ( i < 4 ? i + 1 : - ( i + 1 ) );
                    object.position.y -= 0.95;
                    if(object.position.y <= -500) {
                        object.position.y = 900;
                    }
                }
            }

            for ( let i = 0; i < materials.length; i ++ ) {
                const color = parameters[ i ][ 0 ];
                const h = ( 360 * ( color[ 0 ] + Date.now() * 0.00005 ) % 360 ) / 360;
                materials[ i ].color.setHSL( h, color[ 1 ], color[ 2 ], THREE.SRGBColorSpace );
            }

        }

        prevTime = time;

        renderer.render( scene, camera );

    }

</script>
</body>
</html>